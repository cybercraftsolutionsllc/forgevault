import 'dart:io';

import 'package:flutter/services.dart';
import 'package:path_provider/path_provider.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:share_plus/share_plus.dart';

/// Egress Mint — document export pipeline.
///
/// Handles three export modalities:
/// 1. Copy to Clipboard
/// 2. Export as .MD file (shared to host OS)
/// 3. Mint as PDF (rendered + saved locally)
class ExportMintService {
  ExportMintService._();

  // ─────────────────────────────────────────────────────────────
  // 1. Clipboard
  // ─────────────────────────────────────────────────────────────

  /// Copy raw text to the system clipboard.
  static Future<void> copyToClipboard(String content) async {
    await Clipboard.setData(ClipboardData(text: content));
  }

  // ─────────────────────────────────────────────────────────────
  // 2. Export as Markdown
  // ─────────────────────────────────────────────────────────────

  /// Save content as a .md file and open the system share sheet.
  ///
  /// Returns the path of the saved file.
  static Future<String> exportAsMarkdown({
    required String content,
    required String filename,
  }) async {
    final dir = await getApplicationDocumentsDirectory();
    final mintDir = Directory(
      '${dir.path}${Platform.pathSeparator}vitavault_mint',
    );
    if (!await mintDir.exists()) {
      await mintDir.create(recursive: true);
    }

    final sanitized = filename.replaceAll(RegExp(r'[^\w\-.]'), '_');
    final filePath = '${mintDir.path}${Platform.pathSeparator}$sanitized.md';
    final file = File(filePath);
    await file.writeAsString(content);

    // Share via system share sheet
    await Share.shareXFiles([XFile(filePath)], subject: sanitized);

    return filePath;
  }

  // ─────────────────────────────────────────────────────────────
  // 3. Mint as PDF
  // ─────────────────────────────────────────────────────────────

  /// Render markdown-style text into a styled PDF and save locally.
  ///
  /// Returns the path of the generated PDF file.
  static Future<String> mintAsPdf({
    required String content,
    required String title,
  }) async {
    final dir = await getApplicationDocumentsDirectory();
    final mintDir = Directory(
      '${dir.path}${Platform.pathSeparator}vitavault_mint',
    );
    if (!await mintDir.exists()) {
      await mintDir.create(recursive: true);
    }

    final sanitized = title.replaceAll(RegExp(r'[^\w\-.]'), '_');
    final filePath = '${mintDir.path}${Platform.pathSeparator}$sanitized.pdf';

    final pdf = pw.Document(
      theme: pw.ThemeData.withFont(
        base: pw.Font.courier(),
        bold: pw.Font.courierBold(),
        italic: pw.Font.courierOblique(),
        boldItalic: pw.Font.courierBoldOblique(),
      ),
    );

    // Parse the markdown-ish content into PDF widgets
    final paragraphs = _parseMarkdownToPdfWidgets(content);

    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.letter,
        margin: const pw.EdgeInsets.all(48),
        header: (context) => pw.Container(
          margin: const pw.EdgeInsets.only(bottom: 16),
          padding: const pw.EdgeInsets.only(bottom: 8),
          decoration: const pw.BoxDecoration(
            border: pw.Border(
              bottom: pw.BorderSide(color: PdfColors.grey400, width: 0.5),
            ),
          ),
          child: pw.Row(
            mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
            children: [
              pw.Text(
                'VITAVAULT MINT',
                style: pw.TextStyle(
                  fontSize: 8,
                  fontWeight: pw.FontWeight.bold,
                  color: PdfColors.grey500,
                  letterSpacing: 2,
                ),
              ),
              pw.Text(
                title.toUpperCase(),
                style: pw.TextStyle(
                  fontSize: 8,
                  color: PdfColors.grey500,
                  letterSpacing: 1,
                ),
              ),
            ],
          ),
        ),
        footer: (context) => pw.Container(
          margin: const pw.EdgeInsets.only(top: 12),
          child: pw.Row(
            mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
            children: [
              pw.Text(
                'Generated by VitaVault',
                style: const pw.TextStyle(
                  fontSize: 7,
                  color: PdfColors.grey400,
                ),
              ),
              pw.Text(
                'Page ${context.pageNumber} of ${context.pagesCount}',
                style: const pw.TextStyle(
                  fontSize: 7,
                  color: PdfColors.grey400,
                ),
              ),
            ],
          ),
        ),
        build: (context) => paragraphs,
      ),
    );

    final bytes = await pdf.save();
    final file = File(filePath);
    await file.writeAsBytes(bytes);

    return filePath;
  }

  /// Simple markdown-to-PDF parser.
  ///
  /// Handles: # headings, **bold**, bullet lists, paragraphs.
  static List<pw.Widget> _parseMarkdownToPdfWidgets(String markdown) {
    final widgets = <pw.Widget>[];
    final lines = markdown.split('\n');

    for (final line in lines) {
      final trimmed = line.trim();

      if (trimmed.isEmpty) {
        widgets.add(pw.SizedBox(height: 6));
        continue;
      }

      // H1
      if (trimmed.startsWith('# ')) {
        widgets.add(
          pw.Padding(
            padding: const pw.EdgeInsets.only(top: 12, bottom: 4),
            child: pw.Text(
              trimmed.substring(2),
              style: pw.TextStyle(
                fontSize: 18,
                fontWeight: pw.FontWeight.bold,
                color: PdfColors.grey900,
              ),
            ),
          ),
        );
        continue;
      }

      // H2
      if (trimmed.startsWith('## ')) {
        widgets.add(
          pw.Padding(
            padding: const pw.EdgeInsets.only(top: 10, bottom: 3),
            child: pw.Text(
              trimmed.substring(3),
              style: pw.TextStyle(
                fontSize: 14,
                fontWeight: pw.FontWeight.bold,
                color: PdfColors.grey800,
              ),
            ),
          ),
        );
        continue;
      }

      // H3
      if (trimmed.startsWith('### ')) {
        widgets.add(
          pw.Padding(
            padding: const pw.EdgeInsets.only(top: 8, bottom: 2),
            child: pw.Text(
              trimmed.substring(4),
              style: pw.TextStyle(
                fontSize: 12,
                fontWeight: pw.FontWeight.bold,
                color: PdfColors.grey700,
              ),
            ),
          ),
        );
        continue;
      }

      // Bullet list
      if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
        widgets.add(
          pw.Padding(
            padding: const pw.EdgeInsets.only(left: 16, bottom: 2),
            child: pw.Row(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Text('• ', style: const pw.TextStyle(fontSize: 10)),
                pw.Expanded(
                  child: pw.Text(
                    trimmed.substring(2),
                    style: const pw.TextStyle(
                      fontSize: 10,
                      color: PdfColors.grey800,
                      lineSpacing: 1.4,
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
        continue;
      }

      // Horizontal rule
      if (trimmed == '---' || trimmed == '***') {
        widgets.add(pw.Divider(thickness: 0.5, color: PdfColors.grey300));
        continue;
      }

      // Regular paragraph
      widgets.add(
        pw.Padding(
          padding: const pw.EdgeInsets.only(bottom: 3),
          child: pw.Text(
            trimmed,
            style: const pw.TextStyle(
              fontSize: 10,
              color: PdfColors.grey800,
              lineSpacing: 1.5,
            ),
          ),
        ),
      );
    }

    return widgets;
  }
}
